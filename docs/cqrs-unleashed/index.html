<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>CQRS Unleashed - Tech Blog</title>
        <meta name="description" content="Unlock scalable apps with CQRS & Event Sourcing. Learn patterns & practices for success.">
        <meta name="keywords" content="GitLab, SoftwareArchitecture, CQRS, developer, Event Sourcing pattern, SustainableTech, Microservices, Software Architecture Patterns., DomainDrivenDesign, CQRS pattern, DevOps, Command Query Responsibility Segregation, Microservices Architecture, Event-Driven Architecture, EventDrivenDesign">
            <meta name="google-adsense-account" content="ca-pub-4477679588953789">
    <meta name="google-site-verification" content="AIzaSyBqIII5-K2quNev9w7iJoH5U4uqIqKDkEQ">
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DST4PJYK6V"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-DST4PJYK6V');
    </script>
    <!-- Google AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4477679588953789" 
            crossorigin="anonymous"></script>

        
    <!-- SEO Meta Tags -->
    <meta name="description" content="Unlock scalable apps with CQRS & Event Sourcing. Learn patterns & practices for success.">
    <meta property="og:title" content="CQRS Unleashed">
    <meta property="og:description" content="Unlock scalable apps with CQRS & Event Sourcing. Learn patterns & practices for success.">
    <meta property="og:url" content="https://kubaik.github.io/cqrs-unleashed/">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="Tech Blog">
    <meta property="article:published_time" content="2025-12-31T17:24:23.062137">
    <meta property="article:modified_time" content="2025-12-31T17:24:23.062143">
    <meta property="og:image" content="/static/images/cqrs-unleashed.jpg">
    <meta property="og:image:alt" content="CQRS Unleashed">
    <meta name="twitter:image" content="/static/images/cqrs-unleashed.jpg">

    <!-- Twitter Cards -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="CQRS Unleashed">
    <meta name="twitter:description" content="Unlock scalable apps with CQRS & Event Sourcing. Learn patterns & practices for success.">
    <meta name="twitter:site" content="@KubaiKevin">
    <meta name="twitter:creator" content="@KubaiKevin">

    <!-- Additional SEO -->
    <meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1">
    <meta name="googlebot" content="index, follow">
    <link rel="canonical" href="https://kubaik.github.io/cqrs-unleashed/">
    <meta name="keywords" content="GitLab, SoftwareArchitecture, CQRS, developer, Event Sourcing pattern, SustainableTech, Microservices, Software Architecture Patterns., DomainDrivenDesign, CQRS pattern, DevOps, Command Query Responsibility Segregation, Microservices Architecture, Event-Driven Architecture, EventDrivenDesign">
        <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CQRS Unleashed",
  "description": "Unlock scalable apps with CQRS & Event Sourcing. Learn patterns & practices for success.",
  "author": {
    "@type": "Organization",
    "name": "Tech Blog"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Tech Blog",
    "url": "https://kubaik.github.io",
    "logo": {
      "@type": "ImageObject",
      "url": "https://kubaik.github.io/static/logo.png"
    }
  },
  "datePublished": "2025-12-31T17:24:23.062137",
  "dateModified": "2025-12-31T17:24:23.062143",
  "url": "https://kubaik.github.io/cqrs-unleashed/",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://kubaik.github.io/cqrs-unleashed/"
  },
  "image": {
    "@type": "ImageObject",
    "url": "/static/images/cqrs-unleashed.jpg"
  },
  "keywords": [
    "GitLab",
    "SoftwareArchitecture",
    "CQRS",
    "developer",
    "Event Sourcing pattern",
    "SustainableTech",
    "Microservices",
    "Software Architecture Patterns.",
    "DomainDrivenDesign",
    "CQRS pattern",
    "DevOps",
    "Command Query Responsibility Segregation",
    "Microservices Architecture",
    "Event-Driven Architecture",
    "EventDrivenDesign"
  ]
}
</script>
        <link rel="stylesheet" href="/static/style.css">
    </head>
    <body>
        <!-- Header Ad Slot -->
        <div class="ad-header" style="text-align: center; margin: 20px 0;">
    <ins class="adsbygoogle"
         style="display:inline-block;width:728px;height:90px"
         data-ad-client="ca-pub-4477679588953789"
         
         data-ad-format="leaderboard"
         data-full-width-responsive="true"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
        
        <header>
            <div class="container">
                <h1><a href="/">Tech Blog</a></h1>
                <nav>
                    <a href="/">Home</a>
                    <a href="/about/">About</a>
                    <a href="/contact/">Contact</a>
                    <a href="/privacy-policy/">Privacy Policy</a>
                    <a href="/terms-of-service/">Terms of Service</a>
                </nav>
            </div>
        </header>
        <main class="container">
            <article class="blog-post">
                <header class="post-header">
                    <h1>CQRS Unleashed</h1>
                    <div class="post-meta">
                        <time datetime="2025-12-31T17:24:23.062137">2025-12-31</time>
                        
                        <div class="tags">
                            
                            <span class="tag">GitLab</span>
                            
                            <span class="tag">SoftwareArchitecture</span>
                            
                            <span class="tag">DataScience</span>
                            
                            <span class="tag">SustainableTech</span>
                            
                            <span class="tag">developer</span>
                            
                            <span class="tag">Microservices</span>
                            
                            <span class="tag">DDD</span>
                            
                            <span class="tag">CQRS</span>
                            
                            <span class="tag">DomainDrivenDesign</span>
                            
                            <span class="tag">WebDev</span>
                            
                            <span class="tag">DevOps</span>
                            
                            <span class="tag">Command Query Responsibility Segregation</span>
                            
                            <span class="tag">EventDrivenDesign</span>
                            
                            <span class="tag">Event Sourcing</span>
                            
                            <span class="tag">Domain-Driven Design</span>
                            
                        </div>
                        
                    </div>
                </header>
                <div class="post-content">
                    <h2 id="introduction-to-cqrs-and-event-sourcing">Introduction to CQRS and Event Sourcing</h2>
<p>CQRS (Command Query Responsibility Segregation) and Event Sourcing are two patterns that have gained significant attention in recent years, particularly in the context of microservices architecture and distributed systems. By separating the responsibilities of handling commands (writes) and queries (reads), CQRS enables developers to design more scalable and maintainable systems. Event Sourcing, on the other hand, involves storing the history of an application's state as a sequence of events, allowing for greater flexibility and auditing capabilities.</p>
<p>In this article, we will delve into the world of CQRS and Event Sourcing, exploring their benefits, challenges, and implementation details. We will also examine specific tools and platforms that can help you get started with these patterns.</p>
<h3 id="benefits-of-cqrs">Benefits of CQRS</h3>
<p>The benefits of CQRS are numerous:
* <strong>Improved scalability</strong>: By separating the read and write paths, you can optimize each path independently, leading to better performance and scalability.
* <strong>Simplified development</strong>: CQRS allows developers to focus on specific aspects of the system, reducing the complexity of the codebase.
* <strong>Enhanced flexibility</strong>: With CQRS, you can easily add new features or modify existing ones without affecting the entire system.</p>
<h3 id="benefits-of-event-sourcing">Benefits of Event Sourcing</h3>
<p>Event Sourcing offers several advantages:
* <strong>Auditing and debugging</strong>: By storing the history of events, you can easily track changes to the system and debug issues.
* <strong>Flexibility and adaptability</strong>: Event Sourcing enables you to modify the system's behavior without altering the underlying data structure.
* <strong>Improved data consistency</strong>: Event Sourcing ensures that the system's state is consistent and accurate, even in the presence of failures or errors.</p>
<h2 id="implementing-cqrs-with-net-core">Implementing CQRS with .NET Core</h2>
<p>To demonstrate the implementation of CQRS, let's consider a simple example using .NET Core. We will create a basic e-commerce system that allows users to place orders and view their order history.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Command handler</span>
<span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">PlaceOrderCommandHandler</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">ICommandHandler</span><span class="o">&lt;</span><span class="n">PlaceOrderCommand</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">readonly</span><span class="w"> </span><span class="n">IOrderRepository</span><span class="w"> </span><span class="n">_orderRepository</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">PlaceOrderCommandHandler</span><span class="p">(</span><span class="n">IOrderRepository</span><span class="w"> </span><span class="n">orderRepository</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">_orderRepository</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">orderRepository</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="n">Task</span><span class="w"> </span><span class="nf">HandleAsync</span><span class="p">(</span><span class="n">PlaceOrderCommand</span><span class="w"> </span><span class="n">command</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Order</span><span class="p">(</span><span class="n">command</span><span class="p">.</span><span class="n">CustomerId</span><span class="p">,</span><span class="w"> </span><span class="n">command</span><span class="p">.</span><span class="n">ProductId</span><span class="p">,</span><span class="w"> </span><span class="n">command</span><span class="p">.</span><span class="n">Quantity</span><span class="p">);</span>
<span class="w">        </span><span class="k">await</span><span class="w"> </span><span class="n">_orderRepository</span><span class="p">.</span><span class="n">SaveOrderAsync</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Query handler</span>
<span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">GetOrderHistoryQueryHandler</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">IQueryHandler</span><span class="o">&lt;</span><span class="n">GetOrderHistoryQuery</span><span class="p">,</span><span class="w"> </span><span class="n">OrderHistory</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">readonly</span><span class="w"> </span><span class="n">IOrderRepository</span><span class="w"> </span><span class="n">_orderRepository</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">GetOrderHistoryQueryHandler</span><span class="p">(</span><span class="n">IOrderRepository</span><span class="w"> </span><span class="n">orderRepository</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">_orderRepository</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">orderRepository</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="n">Task</span><span class="o">&lt;</span><span class="n">OrderHistory</span><span class="o">&gt;</span><span class="w"> </span><span class="n">HandleAsync</span><span class="p">(</span><span class="n">GetOrderHistoryQuery</span><span class="w"> </span><span class="n">query</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="n">_orderRepository</span><span class="p">.</span><span class="n">GetOrdersAsync</span><span class="p">(</span><span class="n">query</span><span class="p">.</span><span class="n">CustomerId</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">OrderHistory</span><span class="p">(</span><span class="n">orders</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>In this example, we define two handlers: <code>PlaceOrderCommandHandler</code> for handling the <code>PlaceOrderCommand</code> and <code>GetOrderHistoryQueryHandler</code> for handling the <code>GetOrderHistoryQuery</code>. The <code>IOrderRepository</code> interface is used to abstract the data access layer.</p>
<h2 id="event-sourcing-with-apache-kafka">Event Sourcing with Apache Kafka</h2>
<p>Apache Kafka is a popular messaging platform that can be used to implement Event Sourcing. By storing events in a Kafka topic, you can create a scalable and fault-tolerant event store.</p>
<p>Here's an example of how you can produce and consume events using the Confluent Kafka .NET client:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Produce an event</span>
<span class="kt">var</span><span class="w"> </span><span class="n">producer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ProducerBuilder</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ProducerConfig</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">BootstrapServers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;localhost:9092&quot;</span>
<span class="p">}).</span><span class="n">Build</span><span class="p">();</span>

<span class="kt">var</span><span class="w"> </span><span class="n">eventMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Message</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Guid</span><span class="p">.</span><span class="n">NewGuid</span><span class="p">().</span><span class="n">ToString</span><span class="p">(),</span>
<span class="w">    </span><span class="n">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JsonConvert</span><span class="p">.</span><span class="n">SerializeObject</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">OrderPlacedEvent</span><span class="p">(</span><span class="n">customerId</span><span class="p">,</span><span class="w"> </span><span class="n">productId</span><span class="p">,</span><span class="w"> </span><span class="n">quantity</span><span class="p">))</span>
<span class="p">};</span>

<span class="n">producer</span><span class="p">.</span><span class="n">ProduceAsync</span><span class="p">(</span><span class="s">&quot;orders&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">eventMessage</span><span class="p">).</span><span class="n">Wait</span><span class="p">();</span>

<span class="c1">// Consume events</span>
<span class="kt">var</span><span class="w"> </span><span class="n">consumer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConsumerBuilder</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ConsumerConfig</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">BootstrapServers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;localhost:9092&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="n">GroupId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;orders-group&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="n">AutoOffsetReset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AutoOffsetReset</span><span class="p">.</span><span class="n">Earliest</span>
<span class="p">}).</span><span class="n">Build</span><span class="p">();</span>

<span class="n">consumer</span><span class="p">.</span><span class="n">Subscribe</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;orders&quot;</span><span class="w"> </span><span class="p">});</span>

<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">var</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">consumer</span><span class="p">.</span><span class="n">Consume</span><span class="p">();</span>
<span class="w">    </span><span class="kt">var</span><span class="w"> </span><span class="n">@event</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JsonConvert</span><span class="p">.</span><span class="n">DeserializeObject</span><span class="o">&lt;</span><span class="n">OrderPlacedEvent</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">Message</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
<span class="w">    </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&quot;Received event: {@event.CustomerId} - {@event.ProductId} - {@event.Quantity}&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>In this example, we produce an <code>OrderPlacedEvent</code> and consume it using a Kafka consumer.</p>
<h2 id="common-problems-and-solutions">Common Problems and Solutions</h2>
<p>When implementing CQRS and Event Sourcing, you may encounter several challenges:
1. <strong>Data consistency</strong>: Ensuring data consistency across the system can be difficult, especially in distributed systems. To address this, you can use techniques like event versioning and conflict resolution.
2. <strong>Event handling</strong>: Handling events correctly can be tricky, especially when dealing with failures or errors. To address this, you can use retries, dead-letter queues, and poison message handling.
3. <strong>Scalability</strong>: Scaling the system to handle high volumes of traffic can be challenging. To address this, you can use load balancing, caching, and content delivery networks (CDNs).</p>
<p>Some specific solutions to these problems include:
* Using a message queue like Apache Kafka or Amazon SQS to handle event publishing and consumption.
* Implementing a retry mechanism using a library like Polly or a custom implementation.
* Using a caching layer like Redis or Memcached to improve query performance.</p>
<h2 id="use-cases-and-implementation-details">Use Cases and Implementation Details</h2>
<p>Here are some concrete use cases for CQRS and Event Sourcing:
* <strong>E-commerce platform</strong>: An e-commerce platform can use CQRS to handle orders, inventory, and customer data. Event Sourcing can be used to track order history, inventory changes, and customer interactions.
* <strong>Banking system</strong>: A banking system can use CQRS to handle transactions, account management, and customer data. Event Sourcing can be used to track transaction history, account changes, and customer interactions.
* <strong>Content management system</strong>: A content management system can use CQRS to handle content creation, editing, and publishing. Event Sourcing can be used to track content changes, revisions, and publishing history.</p>
<p>When implementing CQRS and Event Sourcing, consider the following:
* <strong>Use a message queue</strong>: Use a message queue like Apache Kafka or Amazon SQS to handle event publishing and consumption.
* <strong>Implement event versioning</strong>: Implement event versioning to ensure data consistency and handle changes to the event schema.
* <strong>Use a caching layer</strong>: Use a caching layer like Redis or Memcached to improve query performance.</p>
<h2 id="performance-benchmarks">Performance Benchmarks</h2>
<p>To demonstrate the performance benefits of CQRS and Event Sourcing, consider the following benchmarks:
* <strong>Apache Kafka</strong>: Apache Kafka can handle up to 100,000 messages per second, with a latency of around 10-20 milliseconds.
* <strong>Amazon SQS</strong>: Amazon SQS can handle up to 10,000 messages per second, with a latency of around 10-20 milliseconds.
* <strong>Redis</strong>: Redis can handle up to 100,000 requests per second, with a latency of around 1-2 milliseconds.</p>
<p>In terms of pricing, consider the following:
* <strong>Apache Kafka</strong>: Apache Kafka is open-source and free to use.
* <strong>Amazon SQS</strong>: Amazon SQS costs around $0.000004 per request, with a free tier of 1 million requests per month.
* <strong>Redis</strong>: Redis costs around $0.017 per hour, with a free tier of 30MB of memory.</p>
<h2 id="tools-and-platforms">Tools and Platforms</h2>
<p>Some popular tools and platforms for implementing CQRS and Event Sourcing include:
* <strong>Apache Kafka</strong>: A messaging platform for handling event publishing and consumption.
* <strong>Amazon SQS</strong>: A message queue for handling event publishing and consumption.
* <strong>Redis</strong>: A caching layer for improving query performance.
* <strong>Event Store</strong>: A dedicated event store for handling event sourcing.
* <strong>NServiceBus</strong>: A messaging platform for handling event publishing and consumption.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In conclusion, CQRS and Event Sourcing are powerful patterns for building scalable and maintainable systems. By separating the responsibilities of handling commands and queries, CQRS enables developers to design more efficient and scalable systems. Event Sourcing, on the other hand, provides a flexible and adaptable way to store and manage data.</p>
<p>To get started with CQRS and Event Sourcing, consider the following actionable next steps:
* <strong>Learn more about CQRS and Event Sourcing</strong>: Read articles, books, and online courses to learn more about these patterns.
* <strong>Choose a messaging platform</strong>: Select a messaging platform like Apache Kafka or Amazon SQS to handle event publishing and consumption.
* <strong>Implement a caching layer</strong>: Use a caching layer like Redis or Memcached to improve query performance.
* <strong>Start small</strong>: Begin with a small pilot project to test and refine your implementation.
* <strong>Monitor and optimize</strong>: Monitor your system's performance and optimize as needed to ensure scalability and reliability.</p>
<p>By following these steps and leveraging the power of CQRS and Event Sourcing, you can build more efficient, scalable, and maintainable systems that meet the demands of modern applications.</p>
                    
                    <!-- Middle Ad Slot -->
                    <div class="ad-middle" style="text-align: center; margin: 20px 0;">
    <ins class="adsbygoogle"
         style="display:inline-block;width:300px;height:250px"
         data-ad-client="ca-pub-4477679588953789"
         
         data-ad-format="rectangle"
         data-full-width-responsive="true"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
                </div>
                
                <!-- Affiliate Disclaimer -->
                
            </article>
        </main>
        
        <!-- Footer Ad Slot -->
        <div class="ad-footer" style="text-align: center; margin: 20px 0;">
    <ins class="adsbygoogle"
         style="display:inline-block;width:468px;height:60px"
         data-ad-client="ca-pub-4477679588953789"
         
         data-ad-format="banner"
         data-full-width-responsive="true"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
        
        <footer>
            <div class="container">
                <p>&copy; 2026 Tech Blog. Powered by AI.</p>
            </div>
        </footer>
        <!-- Enhanced Navigation Script -->
        <script src="/static/navigation.js"></script>
    </body>
    </html>